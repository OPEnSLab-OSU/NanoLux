<!DOCTYPE html>
<html>
<head>
<title>API Docs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h2>NanoLux API Documentation</h2>
<p>This document is designed to aid developers in utilizing the <strong>Nanolux</strong> web API to add functionality to the open-source AudioLux device.</p>
<h3>Overview</h3>
<p>The API is split into two parts: the part residing on the microcontroller and the part residing inside a JavaScript application. The API is designed to work with the supplied web and mobile apps, but any developer can create their own front-end to the device.</p>
<p>GET requests are relatively simple. Some GET requests in the API require an added string query. The function on the ESP32 side will package all relative data into a return package, and send it back to the JavaScript side.</p>
<p>PUT requests are more complex. The sender (JavaScript) must package all needed information into a single structure, then supply it to the API call. The ESP32 will receive that package, unpack it, then assign all variables the new values they need from that package.</p>
<p>Each API call will be structured as seen below:</p>
<hr />
<p><strong>API_EXAMPLE</strong></p>
<p>ESP32: <em>C FUNCTION CALL NAME</em></p>
<ul>
<li>VARIABLE NAME 1 -&gt; JSON HEADER 1</li>
<li>VARIABLE NAME 2 -&gt; JSON HEADER 2</li>
<li>VARIABLE NAME 3 -&gt; JSON HEADER 3</li>
<li>VARIABLE NAME 4 -&gt; JSON HEADER 4</li>
</ul>
<p><strong>OR, IF NESTED JSON</strong></p>
<ul>
<li>
ITEM
<ul>
<li>SUBITEM 1</li>
<li>SUBITEM 2</li>
<li>SUBITEM 3</li>
<li>SUBITEM 4</li>
</ul>
</li>
</ul>
<p>JavaScript: <em>JS FUNCTION CALL NAME</em></p>
<p>Query: QUERY NAME</p>
<p>Description: Any relevant information will go here.</p>
<hr />
<h3>Regular API</h3>
<p>This section provides API endpoints to access data related to the LED strip. Most functionality for most users will be included in this section. The relevant files are api.h and api.js.</p>
<hr />
<p><strong>Pattern List GET Request</strong></p>
<p>ESP32: handle_patterns_list_request</p>
<ul>
<li>
pattern_list
<ul>
<li>index</li>
<li>name</li>
</ul>
</li>
</ul>
<p>JavaScript: getPatternList()</p>
<p>This function returns the index and associated string name for each pattern. The object returned to the JavaScript side is a nested JSON document. If the user stores the output of the API call in a variable named &quot;patterns,&quot; then the JSON could be mapped into a list of options as such:</p>
<pre><code>const patternOptions = patterns.map(p =&gt; {
    return &lt;option key={p.index} value={p.index}&gt;
        {p.name}
    &lt;/option&gt;
});
</code></pre>

<hr />
<p><strong>Loaded Subpattern GET Request</strong></p>
<p>ESP32: handle_loaded_subpattern_get_request</p>
<ul>
<li>subpattern.idx -&gt; idx</li>
<li>subpattern.brightness -&gt; brightness</li>
<li>subpattern.smoothing -&gt; smoothing</li>
</ul>
<p>JavaScript: getLoadedSubpattern(subpattern_id)</p>
<p>Query:</p>
<ul>
<li>subpattern: The ID of the running subpattern to get information from (between 1 and NUM_SUBPATTERNS)</li>
</ul>
<p>This API call obtains all parameters of the currently-running subpattern the user wishes to access. It is possible to access subpatterns that aren't currently running on the LED strip, but still have stored data on the device. If the user has a React state named data with a set function named setData storing a JavaScript dictionary, all data can be loaded into that dictionary state with the following code:</p>
<pre><code>getLoadedSubpattern(subpattern).then(data =&gt; {setData(data)})
</code></pre>

<hr />
<p><strong>Loaded Pattern Settings GET Request</strong></p>
<p>ESP32: handle_loaded_pattern_settings_get_request</p>
<ul>
<li>loaded_pattern.subpattern_count -&gt; subpattern_count</li>
<li>loaded_pattern.alpha -&gt; alpha</li>
<li>loaded_pattern.mode -&gt; mode</li>
<li>loaded_pattern.noise_thresh -&gt; noise</li>
</ul>
<p>JavaScript: getLoadedPatternSettings()</p>
<p>This API call returns all settings that apply to the running pattern (and by extension all running subpatterns as well). If the user has a React state named data with a set function named setData storing a JavaScript dictionary, all data can be loaded into that dictionary state with the following code:</p>
<pre><code>getLoadedPatternSettings().then(data =&gt; setData(data))
</code></pre>

<hr />
<p><strong>System Settings GET Request</strong></p>
<p>ESP32: handle_system_settings_get_request</p>
<ul>
<li>config.length -&gt; length</li>
<li>config.loop_ms -&gt; loop</li>
<li>config.debug_mode -&gt; debug</li>
</ul>
<p>JavaScript: getSystemSettings()</p>
<p>This API call returns all &quot;system level&quot; settings. If the user has a React state named data with a set function named setData storing a JavaScript dictionary, all data can be loaded into that dictionary state with the following code:</p>
<pre><code>getSystemSettings().then(data =&gt; setData(data))
</code></pre>

<hr />
<p><strong>Loaded Subpattern PUT Request</strong></p>
<p>ESP32: handle_subpattern_update_put_request</p>
<p>JavaScript: updateLoadedSubpattern()</p>
<ul>
<li>idx -&gt; loaded_pattern.subpattern[subpattern_num].idx</li>
<li>bright -&gt; loaded_pattern.subpattern[subpattern_num].brightness</li>
<li>smooth -&gt; loaded_pattern.subpattern[subpattern_num].smoothing</li>
</ul>
<p>Query: Subpattern ID</p>
<p>This API call updates data for a specified subpattern ID. The JavaScript API call can be used as below:</p>
<pre><code>updateLoadedSubpattern(subpattern_num, data);
</code></pre>

<p>The function expects <em>data</em> to be a dictionary with the following fields, with individual elements set to their new value:</p>
<pre><code>const [data, setData] = useState({
    idx: 0,
    brightness: 255,
    smoothing: 0,
});
</code></pre>

<hr />
<p><strong>Loaded Pattern PUT Request</strong></p>
<p>ESP32: handle_pattern_update_put_request</p>
<p>JavaScript: updateLoadedPattern()</p>
<ul>
<li>subpattern<em>count -&gt; loaded</em>pattern.subpattern_count</li>
<li>alpha -&gt; loaded_pattern.alpha</li>
<li>noise -&gt; loaded<em>pattern.noise</em>thresh</li>
<li>mode -&gt; loaded_pattern.mode</li>
</ul>
<p>This API call updates data for the currently-running pattern. The JavaScript API call can be used as below:</p>
<pre><code>updateLoadedPattern(data);
</code></pre>

<p>The function expects <em>data</em> to be a dictionary with the following fields, with individual elements set to their new value:</p>
<pre><code>const [data, setData] = useState({
    subpattern_count: 1,
    alpha: 0,
    mode: 0,
    noise: 20
});
</code></pre>

<hr />
<p><strong>System Settings PUT Request</strong></p>
<p>ESP32: handle_system_settings_put_request</p>
<p>JavaScript: updateDeviceSettings();</p>
<ul>
<li>length -&gt; config.length</li>
<li>loop -&gt; config.loop_ms</li>
<li>debug -&gt; config.debug_mode</li>
</ul>
<p>This API call updates system settings of the microcontroller. The JavaScript API call can be used as below:</p>
<pre><code>updateDeviceSettings(data);
</code></pre>

<p>The function expects <em>data</em> to be a dictionary with the following fields, with individual elements set to their new value:</p>
<pre><code>const [data, setData] = useState({
    length: 60,
    loop: 40,
    debug: 0
});
</code></pre>

<hr />
<p><strong>Save to Slot PUT request</strong></p>
<p>ESP32: handle_save_to_slot_put_request</p>
<p>JavaScript: saveToSlot()</p>
<p>This API call requests the microcontroller to save the currently-running pattern (and all of its subpatterns) to an NVS slot. JavaScript usage is seen below, with <em>slot</em> refering to the numbered slot to save over. Nanolux considers slot 0 to be the save slot loaded on power up.</p>
<pre><code>await saveToSlot(idx);
</code></pre>

<hr />
<p><strong>Load Save Slot PUT request</strong></p>
<p>ESP32: handle_load_save_slot_put_request</p>
<p>JavaScript: loadSaveSlot()</p>
<p>This API call requests the microcontroller to load the pattern saved in a particular NVS save slot to &quot;active&quot; status. Effectively, this means the object responsible for holding the currently-running pattern and subpatterns to the loaded object storing information for a different pattern and subpatterns. JavaScript usage is seen below:</p>
<pre><code>await loadSaveSlot(idx);
window.location.reload(true);
</code></pre>

<p>The web app, upon requesting a load, refreshes the web page as an easy way to force all objects on the web app to quickly update.</p>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
